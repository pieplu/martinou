;
; TITRE:         "martinou"       TRI, programme du TP3 INF2170, hiver 2013
; DATE:          23 avril 2013
; AUTEURS:       Florient Baumont BAUF12059008    baumont.florian@courrier.uqam.ca
;                Alexis Piéplu    PIEA07058900    pieplu.alexis@courrier.uqam.ca
;
; DESCRIPTION:   Programme qui tri un maximum de 5 numéros de pièce de monnaie.
;
         STRO    bienvenu,d 
loop:    LDA     tab,i       
         LDX     tabLen,i   
calllir: CALL    lireTab
         LDA     tab,i
         CALL    TRI     
         STOP 
;
; ----   LE TABLEAU   ----
; ------------------------            
tab:     .BLOCK  56          ; le tableau des numeros #1d56a
debord:  .BLOCK  1           
tabLen:  .EQUATE 56          ; taille de tab
mTemp:   .BLOCK  9          ; maillon temp    #1d9a
         .BLOCK  20          ; la sécu
;
;
; ----   GROS SOUS-PROGRAMME DE REMPLISSAGE  ----
; affecte le tableau de maillions chainé
; -----------------------------------------------
lireTab: SUBSP   6,i         ; reserve var locales #taille #addrt #addrfin
         STA     addrt,s     ; sauvegarde le parametre A
         STX     taille,s    ; sauvegarde le parametre X
         ADDX    addrt,s     
         STX     addrfin,s   ; addrfin = addrt + taille
         LDX     addrt,s     ; for (X=addrt; X<addrfin; X+=2) {
         ADDX    2,i   
         STRO    saisir,d      
lire:    CPX     addrfin,s   
         BRGE    Lirfin       ;fin de la saisie, le tableau est rempli  =====       =TROUVER un truc pour v/rifi/ au<il ne reste rien=   ===== 
         CHARI   0,x         ;;
         LDA     count,d     ;charge le compteur de la taille des numeros de pieces
         ADDA    1,i         ;incremente
         STA     count,d     ;sauve
         CPA     7,i         ;verifie pour la pos du tiret
         BREQ    checkTir    
         CPA     9,i         ;verifie pour la pos max possible de la virgule
         BRNE    okvir       
         CALL    checkVi1    ;#test
okvir:   CPA     10,i        ;verifie pour la pos max possible de la virgule
         BRNE    num         
         CALL    checkVi2    ;#test
num:     LDA     0,i         
         LDBYTEA 0,x         ;
         CPA     '9',i       
         BRGT    erreur      
         CPA     '0',i       
         BRLT    erreur      
suit:    CPA     '\n',i      ; Lire un caractère.
         BREQ    finSaisi    ; ====       =NE PAS OUBLIE, ecraser ce entrer qui traine=      =====
         SUBA    '0',i       
         STBYTEA 0,x         
         ADDX    1,i         ;incremenete pour placer le prochain carac
         BR      lire        
finSaisi:STRO    fini,d      
         
Lirfin:   LDX     taille,s    ; restaure X
         RET6                ; libere #taille #addrt #addrfin
;

;
;
erreur:  STRO    msgErr,d
         ADDSP   6,i             ; libere #taille #addrt #addrfin
; FAIRE LE VIDE de la pile de char
         BR      loop   ; ====   A FAIRE  === 
;
;
; ----   VERIFICATIONS   ----
; verifie les tirets, les virgules et places les longeurs et adresses.
; ---------------------------
checkTir:LDA     0,i         
         LDBYTEA 0,x         
         CPA     '-',i       
         BRNE    erreur    
         BR      lire        

;
checkVi1:LDA     0,i         
         LDBYTEA 0,x         
         CPA     ',',i       
         BRNE    siVir2
         ADDSP   2,i         ; #test
         STBYTEX pointeur,d  ; sauve x, adresse de la suite
         SUBX    count,d     ; vas a l'adresse de la longeur
         ADDX    1,i         ; recalibre
         LDA     count,d
         SUBA    2,i         ; remet le compteur
         STBYTEA 0,x         ; stock la longeur dans sa case
         SUBX    1,i         ; case de l'opé suivant
         LDBYTEA pointeur,d  ; trouve l'adresse relative de l'opé suivant
         ADDA    1,i
         STBYTEA 0,x
         LDA     0,i         
         STA     count,d     ; remet le comteur a zero, pour la suite des opérations
         LDBYTEX pointeur,d  ; recupere x
         ADDX    3,i         ; place x pour la saisie du suivant
         BR      lire                ; si c'est une virgule, donc fin de cette partie
siVir2:  CPA     '\n',i
         BREQ    nonVir      ; == A CHANGER, pour une etiquette du dessous ==         ==========
finVi1:  RET0                
;
checkVi2:LDA     0,i         
         LDBYTEA 0,x         
         CPA     ',',i       
         BRNE    nonVir      
bon:     ADDSP   2,i         ; #test
         STBYTEX pointeur,d  ; sauve x, adresse de la suite
         SUBX    count,d     ; vas a l'adresse de la longeur
         ADDX    1,i         ; recalibre
         LDA     count,d
         SUBA    2,i         ; remet le compteur
         STBYTEA 0,x         ; stock la longeur dans sa case
         SUBX    1,i         ; case de l'opé suivant
         LDBYTEA pointeur,d  ; trouve l'adresse relative de l'opé suivant
         STBYTEA 0,x
         LDA     0,i         
         STA     count,d     ; remet le comteur a zero, pour la suite des opérations
         LDBYTEX pointeur,d  ; recupere x
         ADDX    2,i         ; place x pour la saisie du suivant
         BR      lire        
;
nonVir:  CPA     '\n',i
         BRNE    erreur
         CALL    SfinTab
         LDA     0,i
         STBYTEA 0,x         ; ecrase le 10 qui traine
         ADDSP   2,i         ; #test 
         RET6                ; libere #taille #addrt #addrfin 
;
;
; --- SOUS PROGRAMME --- 
; qui donne l'adresse de fin et la longeur du dernier maillion
; ----------------------
SfinTab:STBYTEX pointeur,d  ; sauve x, adresse de la suite
         SUBX    count,d     ; vas a l'adresse de la longeur
         ADDX    1,i         ; recalibre
         LDA     count,d
         SUBA    2,i         ; remet le compteur
         STBYTEA 0,x         ; stock la longeur dans sa case
         SUBX    1,i         ; case de l'opé suivant
         LDA     0,i  
         STBYTEA 0,x         ; met 0 pour l'opé suivant (C'est la fin)
         STA     count,d     ; remet le comteur a zero, pour la suite des opérations
         LDBYTEX pointeur,d  ; recupere x
         RET0
;
;
;
;
;
; ----   TRI   ----
;
TRI:     SUBSP   2,i           ; #premier 
         STBYTEA addrt,s
         BR      premTri
Bubble:  LDA     flagI,d
         CPA     0,i
         BREQ    trifini 
premTri:LDA     0,i
         STA     flagI,d
         LDX     tab,i
         STX     debutTri,d 
loopBu:  LDX     debutTri,d
         ADDX    1,i
         LDA     0,i
         LDBYTEA 0,x
         STA     long1,d 
         ADDX    10,i
         LDA     0,i
         LDBYTEA 0,x
         CPA     long1,d
         BRNE    sautb1
         CALL    compVal
sautb1: CPA     long1,d
         BRGE    sautb2
         CALL    invers
sautb2: SUBX     1,i
         STX     debutTri,d  
         LDA     0,i
         LDBYTEA 0,x
         CPA     0,i
         BREQ    Bubble
         BR      loopBu
 
;
;
;;;;; SOUS PROGRAMME D'INVERSION   ;;;;;     
invers:  STX     avInvers,d 
         SUBX    1,i
         SUBSP   4,i           ; #m2 #m1 
         
         STX m2,s        ;adresse maillon 2 
         SUBX    10,i
         STX m1,s        ;adresse maillon 1
         LDX     1,i
copM2:   CPX     10,i
         BRGE    M1
         LDA     0,i
         LDBYTEA m2,sxf
         SUBX    1,i
         STBYTEA mTemp,x
         ADDX    2,i
         BR      copM2
M1:      LDX      1,i
copM1:  CPX     10,i 
         BRGE    tTemp
         LDA     0,i
         LDBYTEA m1,sxf
         STBYTEA m2,sxf
         ADDX    1,i
         BR      copM1
 ;              
tTemp:   LDX      0,i
copTemp:CPX     9,i 
         BRGE    finInver
         LDA     0,i
         LDBYTEA mTemp,x
         ADDX    1,i
         STBYTEA m1,sxf
         BR      copTemp
;
finInver:LDX     avInvers,d  ;restaure x
         LDA     1,i
         STA     flagI,d
         RET4    ; libere #m2 #m1 
;;;;; FIN du sous prog inversion   ;;;;; 


;;;;;; SOUS PROGRAMME QUI COMPARE LES VALEURS
compVal: NOP0





trifini:RET2 ; liberre #premier 

;












;
;
addrfin: .EQUATE 0           ; l'adresse de fin du tableau #2h
addrt:   .EQUATE 2           ; l'adresse du tableau #2h
taille:  .EQUATE 4           ; la taille du tableau en octets #2d
test:    .EQUATE 6           ; adresse de retour des sous-prog2 #2h
premier: .EQUATE 0           ; l'adresse du tableau début #2h
fini:    .ASCII  "\n"
         .ASCII  "=========================================\n"
         .ASCII  "               AU REVOIR\n"
         .ASCII  "  À bientôt pour de nouvelles aventures\n"
         .ASCII  "          avec PEP8 et ses amis\n"
         .ASCII  "=========================================\x00"
msgErr:  .ASCII  "Entrée invalide\n\x00"
bienvenu:.ASCII  "=========================================\n"
         .ASCII  "                 MARTINOU\n"
         .ASCII  "-----------------------------------------\n"
         .ASCII  "    Bienvenue dans ce programme de TRI\n"
         .ASCII  "      de numéros de pièce de monnaie\n"
         .ASCII  "-----------------------------------------\n"
         .ASCII  "Entrez-les à la suite les uns des autres\n"
         .ASCII  "séparé d'une virgule et fini par 'entrer'\n"
         .ASCII  "  saisissez juste 'entrer' pour quitter\n"
         .ASCII  "            Maximum 5 numéros\n"
         .ASCII  "=========================================\n\x00"
saisir:  .ASCII  "Entrez un ou plusieurs numéros de pièces:\n\x00"
count:   .WORD   0  
pointeur:.BYTE   0 
;
m2:.EQUATE 0     ; adresse du maillon 2 a inverser #2h
m1:.EQUATE 2     ; adresse du maillon 1 a inverser #2h



flagI:   .WORD   0
avInvers: .BLOCK   2 ; #2d1a
debutTri:.WORD   0 
long1:   .WORD   0     

;;;;; ANCIEN PAS BIEN
long:    .WORD   0
succ:    .WORD   0
nb2:     .WORD   0
temp:     .WORD   0
tempAV:  .WORD   0
avancer: .WORD   0
lpremier: .WORD   0 

flagD:     .WORD   0
;;;;; ANCIEN PAS BIOEN

;
;
         .END  



     
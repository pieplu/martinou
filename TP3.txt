;
; Programme principal. Invoque simplement la fonction.
         LDA     tab,i       
         LDX     tabLen,i    
         CALL    lireTab     
         STOP                
tab:     .BLOCK  56          ; un tableau d'entiers #1d56a
debord:  .BLOCK  1           
tabLen:  .EQUATE 56          ; taille de tab en octets
;
; readTab: lit un tableau d'entiers (de l'input)
; IN: A=tableau d'entiers (mots signés #2d)
;     X=taille du tableau en octets
; En cas de probleme de lecture, le programme s'arrete
lireTab: SUBSP   6,i         ; reserve var locales #taille #addrt #addrfin
         STA     addrt,s     ; sauvegarde le parametre A
         STX     taille,s    ; sauvegarde le parametre X
         ADDX    addrt,s     
         STX     addrfin,s   ; addrfin = addrt + taille
         LDX     addrt,s     ; for (X=addrt; X<addrfin; X+=2) {
         ADDX    2,i         
lire:    CPX     addrfin,s   
         BRGE    rTfin       ;fin de la saisie, le tableau est rempli  TROUVER un truc pour v/rifi/ au<il ne reste rien
         CHARI   0,x         ;;
         LDA     count,d     ;charge le compteur de la taille des numeros de pieces
         ADDA    1,i         ;incremente
         STA     count,d     ;sauve
         CPA     7,i         ;verifie pour la pos du tiret
         BREQ    checkTir    
         CPA     9,i         ;verifie pour la pos max possible de la virgule
         BRNE    okvir       
         CALL    checkVi1    ;#test
okvir:   CPA     10,i        ;verifie pour la pos max possible de la virgule
         BRNE    num         
         CALL    checkVi2    ;#test
;
num:     LDA     0,i         
         LDBYTEA 0,x         ;
         CPA     '9',i       
         BRGT    erreur      
         CPA     '0',i       
         BRLT    erreur      
;
;
suit:    CPA     '\n',i      ; Lire un caractère.
         BREQ    finSaisi    ; ====       =NE PAS OUBLIE, ecraser ce entrer qui traine=      =====
         SUBA    '0',i       
         STBYTEA 0,x         
         ADDX    1,i         ;incremenete pour placer le prochain carac
         BR      lire        
finSaisi:STRO    fini,d      
         BR      rTfin       
;
;
;
         DECI    0,x         ;   *addrt = readInt();
         ADDX    2,i         
         BR      lire        ; } // fin for
rTfin:   LDX     taille,s    ; restaure X
         RET6                ; libere #taille #addrt #addrfin
;
;
; Verif======
checkTir:LDA     0,i         
         LDBYTEA 0,x         
         CPA     '-',i       
         BRNE    erreur      
         BR      lire        
;
;
erreur:  BR      finSaisi    
;
;
checkVi1:LDA     0,i         
         LDBYTEA 0,x         
         CPA     ',',i       
         BREQ    bon         ; si c'est une virgule, donc fin de cette partie
finVi1:  RET0                
;
checkVi2:LDA     0,i         
         LDBYTEA 0,x         
         CPA     ',',i       
         BRNE    errVir      
bon:     ADDSP   2,i         ;#test
         
         LDA     0,i         
         STA     count,d     
         BR      lire        
;
errVir:  RET0                ; ===        =A FAIRE  =============== attention, aux ret machin et cie
;
addrfin: .EQUATE 0           ; l'adresse de fin du tableau #2h
addrt:   .EQUATE 2           ; l'adresse du tableau #2h
taille:  .EQUATE 4           ; la taille du tableau en octets #2d
test:    .EQUATE 6           ; adresse de retour des sous-prog2 #2h
fini:    .ASCII  "fin de lecture\x00"
count:   .WORD   0           
;
;
         .END                  